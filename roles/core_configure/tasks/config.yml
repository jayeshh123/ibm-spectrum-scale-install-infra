---
# Define nodeclasses and configuration parameters

#
# Inspect existing nodeclasses, config params and inventory
#
- name: config | Group hosts by defined nodeclasses
  group_by:
    key: scale_nodeclass_{{ item }}
  when: scale_nodeclass is defined
  with_items: "{{ scale_nodeclass }}"

- name: config | Initialize undefined variables
  set_fact:
    scale_config: []
  when: scale_config is undefined

- block:  ## run_once: true
    - name: config | Find existing nodeclasses
      shell: /usr/lpp/mmfs/bin/mmlsnodeclass --user -Y | grep -v HEADER | cut -d ':' -f 7
      register: scale_config_existing_nodeclasses
      changed_when: false
      failed_when: false

    - name: config | Find existing configuration parameters
      shell: /usr/lpp/mmfs/bin/mmlsconfig -Y | grep -v HEADER
      register: scale_config_existing_params
      changed_when: false
      failed_when: false

    - name: config | Find defined nodeclasses
      set_fact:
        scale_config_nodeclasses: "{{ scale_config_nodeclasses | default([]) + [ item ] }}"
      with_items: "{{ groups | select('match', '^scale_nodeclass_.*') | list }}"

    - name: config | Prepare NodeClass files
      vars:
        current_nodeclass: "{{ item | regex_replace('^scale_nodeclass_', '') }}"
      template:
        src: NodeClass.j2
        dest: /var/mmfs/tmp/NodeClass.{{ current_nodeclass }}
      register: scale_config_nodeclassfile
      with_items: "{{ scale_config_nodeclasses | default([]) }}"

#
# Create new nodeclasses
#
    - name: config | Create new nodeclasses
      vars:
        current_nodeclass: "{{ item.item | regex_replace('^scale_nodeclass_', '') }}"
      command: /usr/lpp/mmfs/bin/mmcrnodeclass {{ current_nodeclass }} -N /var/mmfs/tmp/NodeClass.{{ current_nodeclass }}
      when:
        - not current_nodeclass in scale_config_existing_nodeclasses.stdout_lines
        - item is changed
        - item.size > 1
      with_items: "{{ scale_config_nodeclassfile.results }}"

#
# Replace existing nodeclasses
#
    - name: config | Replace existing nodeclasses
      vars:
        current_nodeclass: "{{ item.item | regex_replace('^scale_nodeclass_', '') }}"
      command: /usr/lpp/mmfs/bin/mmchnodeclass {{ current_nodeclass }} replace -N /var/mmfs/tmp/NodeClass.{{ current_nodeclass }}
      when:
        - current_nodeclass in scale_config_existing_nodeclasses.stdout_lines
        - item is changed
        - item.size > 1
      with_items: "{{ scale_config_nodeclassfile.results }}"

#
# Apply config params
#
    - name: config | Apply defined configuration parameters
      vars:
        current_key: "{{ item.1.keys() | list | first }}"
        current_value: "{{ item.1[current_key] | string | regex_replace('True', 'yes') | regex_replace('False', 'no') }}"
        current_nodeclass: "{{ item.0.nodeclass }}"
      command: /usr/lpp/mmfs/bin/mmchconfig {{ current_key }}={{ current_value }} -N {{ current_nodeclass }}
      register: scale_config_changed_params
      when:
        not scale_config_existing_params.stdout | lower is
          search(':' + current_key | lower + ':' + current_value | lower + ':(.+,)?' + current_nodeclass | lower | regex_replace('all', '') + '(,.+)?:')
      with_subelements:
        - "{{ ansible_play_hosts | map('extract', hostvars, 'scale_config') | sum(start=[]) | unique }}"
        - params

    - name: Printing scale_config_changed_params
      debug:
        var: true in scale_config_changed_params.results | map(attribute='changed') | list
    
    - name: Printing scale_daemon_running
      debug:
        var: true in ansible_play_hosts | map('extract', hostvars, 'scale_daemon_running') | list
        
    #################################################################
    # Do shutdown the gpfs cluster

    - name: Check if reboot.storagenodegrp file exists on remote server
      stat:
        path: "/var/mmfs/tmp/reboot.storagenodegrp"
      register: reboot_file_stat
      run_once: true
      
    - name: Create reboot.storagenodegrp if it does not exist
      file:
        path: /var/mmfs/tmp/reboot.storagenodegrp
        state: touch
      when: not reboot_file_stat.stat.exists
      run_once: true

    # - name: Copy NodeClass.storagenodegrpm to reboot.storagenodegrp if it does not exist
    #   command: cp /var/mmfs/tmp/NodeClass.storagenodegrpm /var/mmfs/tmp/reboot.storagenodegrp
    #   when: not reboot_file_stat.stat.exists
    #   run_once: true

    - name: Read the content of file1.txt
      command: cat /var/mmfs/tmp/NodeClass.storagenodegrp
      register: file1_content

    - name: Debug file1 content
      debug:
        msg: "Content of file1.txt: {{ file1_content.stdout }}"

    - name: Read the content of file2.txt
      command: cat /var/mmfs/tmp/reboot.storagenodegrp
      register: file2_content

    - name: Debug file2 content
      debug:
        msg: "Content of file2.txt: {{ file2_content.stdout }}"

    - name: Split file1 content into a list
      set_fact:
        file1_list: "{{ file1_content.stdout_lines }}"

    - name: Debug file1 list
      debug:
        msg: "List from file1.txt: {{ file1_list }}"

    - name: Split file2 content into a list
      set_fact:
        file2_list: "{{ file2_content.stdout_lines }}"

    - name: Debug file2 list
      debug:
        msg: "List from file2.txt: {{ file2_list }}"

    - name: Find names unique to file1
      set_fact:
        unique_names: "{{ file1_list | difference(file2_list) }}"

    - name: Convert unique names to comma-separated string
      set_fact:
        unique_names_str: "{{ unique_names | join(',') }}"

    - name: Debug unique names
      debug:
        msg: "Unique names: {{ unique_names_str }}"

    - name: Append unique names to file2.txt if not empty
      lineinfile:
        path: /var/mmfs/tmp/reboot.storagenodegrp
        line: "{{ item }}"
      loop: "{{ unique_names }}"
      when: unique_names | length > 0

    - name: Debug final content of file2.txt
      command: cat /var/mmfs/tmp/reboot.storagenodegrp
      register: final_file2_content

    - name: Print final content of file2.txt
      debug:
        msg: "Final content of file2.txt: {{ final_file2_content.stdout }}"
    
    - name: Shutdown gpfs cluster if there are unique names
      command: /usr/lpp/mmfs/bin/mmshutdown -N {{ unique_names_str }}
      register: shutdown_gpfs_cluster
      when: unique_names_str | length > 0

    - name: Wait for 10-second 
      pause:
        seconds: 10
      when: unique_names_str | length > 0
        
    - name: cluster | Startup gpfs cluster
      command: /usr/lpp/mmfs/bin/mmstartup -N {{ unique_names_str }}
      register: started_gpfs_cluster
      when: shutdown_gpfs_cluster.changed == true

    - name: Wait for 10-second 
      pause:
        seconds: 10
      when: started_gpfs_cluster.changed == true
    

    # - name: Check if reboot.storagenodegrp file exists on remote server
    #   stat:
    #     path: "/var/mmfs/tmp/reboot.storagenodegrp"
    #   register: reboot_file_stat
    #   run_once: true

    # - name: Create reboot.storagenodegrp if it does not exist
    #   file:
    #     path: /var/mmfs/tmp/reboot.storagenodegrp
    #     state: touch
    #   when: not reboot_file_stat.stat.exists
    #   run_once: true

    # - name: Read NodeClass.storagenodegrp
    #   slurp:
    #     src: /var/mmfs/tmp/NodeClass.storagenodegrp
    #   register: NodeClass_storagenodegrp_name
    #   run_once: true

    # - name: Read reboot.storagenodegrp
    #   slurp:
    #     src: /var/mmfs/tmp/reboot.storagenodegrp
    #   register: reboot_storagenodegrp_name
    #   run_once: true

    # - name: Convert NodeClass.storagenodegrp content to list
    #   set_fact:
    #     NodeClass_storagenodegrp_file: "{{ NodeClass_storagenodegrp_name.content | b64decode | split('\n') }}"
    #   run_once: true

    # - name: Convert reboot.storagenodegrp content to list
    #   set_fact:
    #     reboot_storagenodegrp_file: "{{ reboot_storagenodegrp_name.content | b64decode | split('\n') }}"
    #   run_once: true

    # - name: Find newly added nodes
    #   set_fact:
    #     newly_added_nodes: "{{ NodeClass_storagenodegrp_file | difference(reboot_storagenodegrp_file) }}"
    #   run_once: true

    # - name: Overwrite reboot.storagenodegrp with newly node names
    #   copy:
    #     content: "{{ newly_added_nodes | join('\n') + '\n' }}"
    #     dest: /var/mmfs/tmp/reboot.storagenodegrp
    #   run_once: true
    
    # - name: Check if reboot.storagenodegrp has new node names
    #   shell: "cat /var/mmfs/tmp/reboot.storagenodegrp"
    #   register: reboot_storagenodegrp_content_check
    #   changed_when: false

    # - name: Set fact if reboot.storagenodegrp has content
    #   set_fact:
    #     reboot_storagenodegrp: "{{ reboot_storagenodegrp_content_check.stdout != '' }}"

    # - name: cluster | Shutdown gpfs cluster 
    #   command: /usr/lpp/mmfs/bin/mmshutdown -N /var/mmfs/tmp/reboot.storagenodegrp
    #   register: shutdown_gpfs_cluster
    #   when: reboot_storagenodegrp

    # - name: Wait for 10-second 
    #   pause:
    #     seconds: 10
    #   when: reboot_storagenodegrp
        
    # - name: cluster | Startup gpfs cluster
    #   command: /usr/lpp/mmfs/bin/mmstartup -N /var/mmfs/tmp/reboot.storagenodegrp
    #   register: started_gpfs_cluster
    #   when: shutdown_gpfs_cluster.changed == true

    # - name: Wait for 10-second 
    #   pause:
    #     seconds: 10
    #   when: started_gpfs_cluster.changed == true

      #################################################################
    - name: config | Check if configuration parameters were changed
      set_fact:
        scale_config_changed: true
      when:
        - true in scale_config_changed_params.results | map(attribute='changed') | list
        - true in ansible_play_hosts | map('extract', hostvars, 'scale_daemon_running') | list
  run_once: true

- block:
    - name: config | Check if ephemeral ports is exists
      command: "{{ scale_command_path }}mmlsconfig tscCmdPortRange"
      register: scale_portrange

    - name: config | Setting ephemeral ports for GPFS daemon communication
      vars:
         ephemeral_ports: "{{ scale_cluster_config.ephemeral_port_range }}"
      command: "{{ scale_command_path }}mmchconfig tscCmdPortRange={{ ephemeral_ports }}"
      when:
         - "'undefined' in scale_portrange.stdout"
      register: scale_portrange_chnage

    - debug:
         msg: "{{ scale_portrange_chnage.cmd }}"
      when: scale_portrange_chnage.cmd is defined
      ignore_errors: yes

  when:
    - scale_cluster_config is defined and scale_cluster_config.ephemeral_port_range is defined
  run_once: true

- block:
    - name: config | Check if numaMemoryInterleave config for s390x is set to yes
      command: "{{ scale_command_path }}mmlsconfig numaMemoryInterleave"
      register: scale_numamemory
      failed_when: false

    - name: config | Setting numaMemoryInterleave config for s390x
      command: "{{ scale_command_path }}mmchconfig numaMemoryInterleave=no"
      when:
         - scale_numamemory.stdout is defined
         - "'yes' in scale_numamemory.stdout"
      register: scale_numamemory_cmd
      failed_when: false

    - debug:
         msg: "{{ scale_numamemory_cmd.cmd }}"
      when: scale_numamemory_cmd.cmd is defined
      ignore_errors: yes
      failed_when: false

  when:
    - ansible_architecture == "s390x"
  ignore_errors: yes
  run_once: true
